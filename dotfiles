#!/usr/bin/env python

import os
import sys
import shutil
import subprocess

# DOTFILES_DIR = os.path.expanduser('~/.dotfiles')
# INNER_HOME_DIR = os.path.join(DOTFILES_DIR, 'home')
# FILES_LIST_PATH = os.path.join(DOTFILES_DIR, 'files.txt')
# SUBMODULES_LIST_PATH = os.path.join(DOTFILES_DIR, 'submodules.txt')

class DotfileManager(object):
    BLACKLIST = ['.git']

    def __init__(self, home_dir=None, dotfile_dir=None):
        super(DotfileManager, self).__init__()
        if home_dir is None:
            home_dir = os.path.expanduser('~')
        if dotfile_dir is None:
            dotfile_dir = os.path.dirname(os.path.abspath(__file__))

        self.home_dir = home_dir
        self.dotfile_dir = dotfile_dir

    def update(self):
        sys.stdout.write('Updating dotfiles...')
        sys.stdout.flush()

        gp = subprocess.Popen('git pull', cwd=self.dotfile_dir, shell=True, stdout=subprocess.PIPE)
        sout, serr = gp.communicate()
        self._print_sout(sout)

        # TODO: handle serr

        gp = subprocess.Popen('git submodule init', cwd=self.dotfile_dir, shell=True, stdout=subprocess.PIPE)
        sout, serr = gp.communicate()
        self._print_sout(sout)

        gp = subprocess.Popen('git submodule update', cwd=self.dotfile_dir, shell=True, stdout=subprocess.PIPE)
        sout, serr = gp.communicate()
        self._print_sout(sout)

        sys.stdout.write('Done!\n')

    def upgrade(self, interactive=True):
        sys.stdout.write('Updating dotfiles...')
        sys.stdout.flush()

        sys.stdout.write('Done!\n')

    def status(self):
        self._walk_dotfiles('')


    def _print_sout(self, sout):
        sout_lines = [line for line in sout.split('\n')]
        if len(sout_lines) > 0 and len(sout_lines[-1]) == 0:
            del sout_lines[-1]
        for l in sout_lines:
            print '\t' + l

    def _confirm(self, msg):
        sys.stdout.write(msg)
        sys.stdout.flush()
        response = raw_input().lower()
        if response.startswith('y'):
            return True
        elif response.startswith('n'):
            return False
        else:
            sys.stdout.write('Unrecognized response!\n')
            return _confirm(msg)
    
    def _walk_dotfiles(self, callback):
        for dirpath, dirname, filenames in os.walk(self.dotfile_dir):
            if callback(dirpath):
                pass
            else:
                pass
            print dirpath
            dirname[:] = [d for d in dirname if d not in self.BLACKLIST]
            # print dirpath
            # print dirname
            # print filenames


# def init(args): # Do we even need this? Just aliasing right now...
    # pull()

# def install(args):
    # _install_bin()

# def pull(args):
    # _git_pull()
    # _symlink_dotfiles()

# def push(args):
    # _update_lists()
    # # _git_push()

# def _git_pull():
    # if os.path.exists(DOTFILES_DIR):
        # subprocess.call('git --work-tree=%s pull' % DOTFILES_DIR, shell=True)
    # else:
        # print 'Cloning Not Implemented Yet!'

    # subprocess.call('git --work-tree=%s submodules init' % DOTFILES_DIR, shell=True)
    # subprocess.call('git --work-tree=%s submodules update' % DOTFILES_DIR, shell=True)
    
# def _git_push():
    # subprocess.call('git --work-tree=%s push' % DOTFILES_DIR, shell=True)

# def _git_add(path):
    # subprocess.call('git --work-tree=%s add %s' % (DOTFILES_DIR, path), shell=True)

# def _update_lists():
    # files = []
    # submodules = []

    # for name in os.listdir(INNER_HOME_DIR):
        # print name
        # path = os.path.join(INNER_HOME_DIR, name)
        # if os.path.isdir(path) and '.git' in os.listdir(path): # Git repo, aka submodule
            # submodules.append(name)
            # continue

        # _git_add(path)

        # dotfilename = '.%s' % name
        # files.append(dotfilename)

    # with open(FILES_LIST_PATH, 'w') as f:
        # f.write('\n'.join(files))

    # with open(SUBMODULES_LIST_PATH, 'w') as f:
        # f.write('\n'.join(submodules))

# def _symlink_dotfiles():
    # files = []
    # if os.path.exists(FILES_LIST_PATH):
        # with open(FILES_LIST_PATH, 'r') as f:
            # files.extend([line for line in f.read().split('\n') if len(line)])

    # print files


# def _install_bin(prefix='/usr', symlink=True):
    # bin_dir = os.path.join(prefix, 'bin')
    # directory, filename = os.path.split(__file__)
    # target_path = os.path.join(bin_dir, filename)

    # if os.path.lexists(target_path):
        # if os.path.exists(target_path): # It really exists and is working
            # # TODO: make it so that we overwrite it isntead of erroring out
            # print 'WARNING: %s already exists, skipping!' % target_path
            # return 
        # else: # It's a broken link
            # if not os.access(bin_dir, os.W_OK):
                # print 'WARNING: Insufficient permissions to install to %s!' % target_path
                # return
            # os.remove(target_path)
    # elif os.path.exists(bin_dir) and not os.access(bin_dir, os.W_OK):
        # print 'WARNING: Insufficient permissions to install to %s!' % target_path
        # return
    # else:
        # print 'ERROR: Unexpected error, %s probably does not exist?' % bin_dir

    # if symlink:
        # os.symlink(os.path.abspath(__file__), target_path)
    # else:
        # shutil.copy2(__file__, target_path)
    # print 'Installed binary to %s' % target_path


def update(args):
    df = DotfileManager()
    df.update()

def upgrade(args):
    df = DotfileManager()
    df.upgrade()

def status(args):
    df = DotfileManager()
    df.status()

if __name__ == '__main__':
    import argparse 
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    parser_update = subparsers.add_parser('update')
    parser_update.set_defaults(subcommand=update)

    parser_upgrade = subparsers.add_parser('upgrade')
    parser_upgrade.set_defaults(subcommand=upgrade)

    parser_status = subparsers.add_parser('status')
    parser_status.set_defaults(subcommand=status)

    # parser_install = subparsers.add_parser('install')
    # parser_install.set_defaults(func=install)

    # parser_init = subparsers.add_parser('init')
    # parser_init.set_defaults(func=init)

    # parser_pull = subparsers.add_parser('pull')
    # parser_pull.set_defaults(func=pull)

    # parser_push = subparsers.add_parser('push')
    # parser_push.set_defaults(func=push)

    args = parser.parse_args()
    args.subcommand(args)
