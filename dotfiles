#!/usr/bin/env python

import os
import shutil
import subprocess

DOTFILES_DIR = os.path.expanduser('~/.dotfiles')
INNER_HOME_DIR = os.path.join(DOTFILES_DIR, 'home')
FILES_LIST_PATH = os.path.join(DOTFILES_DIR, 'files.txt')
SUBMODULES_LIST_PATH = os.path.join(DOTFILES_DIR, 'submodules.txt')

def init(args): # Do we even need this? Just aliasing right now...
    pull()

def install(args):
    _install_bin()

def pull(args):
    _git_pull()
    _symlink_dotfiles()

def push(args):
    _update_lists()
    # _git_push()



def _git_pull():
    if os.path.exists(DOTFILES_DIR):
        subprocess.call('git --work-tree=%s pull' % DOTFILES_DIR, shell=True)
    else:
        print 'Cloning Not Implemented Yet!'

    subprocess.call('git --work-tree=%s submodules init' % DOTFILES_DIR, shell=True)
    subprocess.call('git --work-tree=%s submodules update' % DOTFILES_DIR, shell=True)
    
def _git_push():
    subprocess.call('git --work-tree=%s push' % DOTFILES_DIR, shell=True)

def _git_add(path):
    subprocess.call('git --work-tree=%s add %s' % (DOTFILES_DIR, path), shell=True)

def _update_lists():
    files = []
    submodules = []

    for name in os.listdir(INNER_HOME_DIR):
        print name
        path = os.path.join(INNER_HOME_DIR, name)
        if os.path.isdir(path) and '.git' in os.listdir(path): # Git repo, aka submodule
            submodules.append(name)
            continue

        _git_add(path)

        dotfilename = '.%s' % name
        files.append(dotfilename)

    with open(FILES_LIST_PATH, 'w') as f:
        f.write('\n'.join(files))

    with open(SUBMODULES_LIST_PATH, 'w') as f:
        f.write('\n'.join(submodules))

def _symlink_dotfiles():
    files = []
    if os.path.exists(FILES_LIST_PATH):
        with open(FILES_LIST_PATH, 'r') as f:
            files.extend([line for line in f.read().split('\n') if len(line)])

    print files


def _install_bin(prefix='/usr', symlink=True):
    bin_dir = os.path.join(prefix, 'bin')
    directory, filename = os.path.split(__file__)
    target_path = os.path.join(bin_dir, filename)

    if os.path.lexists(target_path):
        if os.path.exists(target_path): # It really exists and is working
            # TODO: make it so that we overwrite it isntead of erroring out
            print 'WARNING: %s already exists, skipping!' % target_path
            return 
        else: # It's a broken link
            if not os.access(bin_dir, os.W_OK):
                print 'WARNING: Insufficient permissions to install to %s!' % target_path
                return
            os.remove(target_path)
    elif os.path.exists(bin_dir) and not os.access(bin_dir, os.W_OK):
        print 'WARNING: Insufficient permissions to install to %s!' % target_path
        return
    else:
        print 'ERROR: Unexpected error, %s probably does not exist?' % bin_dir

    if symlink:
        os.symlink(os.path.abspath(__file__), target_path)
    else:
        shutil.copy2(__file__, target_path)
    print 'Installed binary to %s' % target_path

if __name__ == '__main__':
    import argparse 
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    parser_install = subparsers.add_parser('install')
    parser_install.set_defaults(func=install)

    parser_init = subparsers.add_parser('init')
    parser_init.set_defaults(func=init)

    parser_pull = subparsers.add_parser('pull')
    parser_pull.set_defaults(func=pull)

    parser_push = subparsers.add_parser('push')
    parser_push.set_defaults(func=push)

    parsed_args = parser.parse_args()
    parsed_args.func(parsed_args)
